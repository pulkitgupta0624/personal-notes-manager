This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
backend/.gitignore
backend/package.json
backend/README.md
backend/server.js
backend/src/app.js
backend/src/config/database.js
backend/src/controllers/authController.js
backend/src/controllers/bookmarkController.js
backend/src/controllers/noteController.js
backend/src/middlewares/auth.js
backend/src/middlewares/errorHandler.js
backend/src/middlewares/validate.js
backend/src/models/Bookmark.js
backend/src/models/Note.js
backend/src/models/User.js
backend/src/routes/authRoutes.js
backend/src/routes/bookmarkRoutes.js
backend/src/routes/noteRoutes.js
backend/src/utils/urlMetadata.js
backend/src/utils/validators.js
frontend/.eslintrc.json
frontend/.gitignore
frontend/jsconfig.json
frontend/next.config.mjs
frontend/package.json
frontend/postcss.config.mjs
frontend/README.md
frontend/tailwind.config.js
package.json
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Dependencies
node_modules/
npm-debug.log
yarn-error.log

# Environment variables
.env
.env.local
.env.*.local

# Build outputs
dist/
build/
out/

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Logs
logs/
*.log

# Backend specific
backend/node_modules/
backend/.env
backend/dist/

# Frontend specific
frontend/node_modules/
frontend/.env.local
frontend/build/
frontend/dist/

# Misc
.cache/
.temp/
</file>

<file path="backend/.gitignore">
# Dependencies
node_modules/
npm-debug.log
yarn-error.log

# Environment variables
.env
.env.local
.env.*.local

# IDE and editor files
.vscode/
.idea/
*.swp
*.swo
*~
.DS_Store

# Build and dist
dist/
build/
*.tsbuildinfo

# Logs
logs/
*.log

# OS files
Thumbs.db
.DS_Store

# Optional npm cache
.npm

# Optional REPL history
.node_repl_history

# Temporary files
tmp/
temp/
</file>

<file path="backend/package.json">
{
  "name": "backend",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "keywords": ["notes", "bookmarks", "api"],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "axios": "^1.13.4",
    "bcryptjs": "^3.0.3",
    "cheerio": "^1.2.0",
    "cors": "^2.8.6",
    "dotenv": "^17.2.4",
    "express": "^5.2.1",
    "express-validator": "^7.3.1",
    "jsonwebtoken": "^9.0.3",
    "mongoose": "^9.1.6"
  }
}
</file>

<file path="backend/README.md">
# ğŸ“ Notes & Bookmarks Manager - Backend API

RESTful API for managing personal notes and bookmarks with optional user authentication.

## ğŸš€ Quick Start

### Prerequisites
- Node.js (v14+)
- MongoDB running locally or MongoDB Atlas account

### Installation

1. **Install dependencies**
```bash
   npm install
```

2. **Configure environment variables**
```bash
   cp .env.example .env
```
   
   Edit `.env` and set:
```env
   PORT=5000
   MONGODB_URI=mongodb://localhost:27017/notes-bookmarks
   JWT_SECRET=your_secret_key_here
   NODE_ENV=development
```

3. **Start MongoDB** (if running locally)
```bash
   mongod
```

4. **Run the server**
```bash
   # Development mode with auto-reload
   npm run dev

   # Production mode
   npm start
```

Server will run on `http://localhost:5000`

## ğŸ“¡ API Endpoints

### Authentication (Bonus Feature)

#### Register User
```http
POST /api/auth/register
Content-Type: application/json

{
  "name": "John Doe",
  "email": "john@example.com",
  "password": "password123"
}
```

#### Login User
```http
POST /api/auth/login
Content-Type: application/json

{
  "email": "john@example.com",
  "password": "password123"
}
```

#### Get Current User
```http
GET /api/auth/me
Authorization: Bearer YOUR_TOKEN
```

### Notes API

#### Get All Notes
```http
GET /api/notes
GET /api/notes?q=search-term
GET /api/notes?tags=work,important
GET /api/notes?q=meeting&tags=work
```

#### Get Single Note
```http
GET /api/notes/:id
```

#### Create Note
```http
POST /api/notes
Content-Type: application/json

{
  "title": "Meeting Notes",
  "content": "Discussed project timeline...",
  "tags": ["work", "important"],
  "isFavorite": false
}
```

#### Update Note
```http
PUT /api/notes/:id
Content-Type: application/json

{
  "title": "Updated Title",
  "content": "Updated content",
  "tags": ["work"],
  "isFavorite": true
}
```

#### Delete Note
```http
DELETE /api/notes/:id
```

### Bookmarks API

#### Get All Bookmarks
```http
GET /api/bookmarks
GET /api/bookmarks?q=search-term
GET /api/bookmarks?tags=tech,tutorial
```

#### Get Single Bookmark
```http
GET /api/bookmarks/:id
```

#### Create Bookmark
```http
POST /api/bookmarks
Content-Type: application/json

{
  "url": "https://example.com",
  "title": "Example Site",
  "description": "A helpful resource",
  "tags": ["tech", "resource"],
  "isFavorite": false
}
```

**Bonus**: Leave `title` empty and it will auto-fetch from the URL!
```json
{
  "url": "https://github.com",
  "tags": ["dev"]
}
```

#### Update Bookmark
```http
PUT /api/bookmarks/:id
Content-Type: application/json

{
  "title": "Updated Title",
  "description": "Updated description",
  "isFavorite": true
}
```

#### Delete Bookmark
```http
DELETE /api/bookmarks/:id
```

## ğŸ” Authentication (Optional)

To use protected routes, include JWT token in Authorization header:
```http
Authorization: Bearer YOUR_JWT_TOKEN
```

The API works **with or without** authentication:
- **Without auth**: All notes/bookmarks are public
- **With auth**: Users only see their own data

## ğŸ“¦ Response Format

### Success Response
```json
{
  "status": "success",
  "data": {
    "notes": [...]
  }
}
```

### Error Response
```json
{
  "status": "error",
  "message": "Error description"
}
```

## ğŸ§ª Testing with cURL

### Create a Note
```bash
curl -X POST http://localhost:5000/api/notes \
  -H "Content-Type: application/json" \
  -d '{
    "title": "Test Note",
    "content": "This is a test",
    "tags": ["test"]
  }'
```

### Get All Notes
```bash
curl http://localhost:5000/api/notes
```

### Search Notes
```bash
curl "http://localhost:5000/api/notes?q=test&tags=important"
```

## ğŸ› ï¸ Tech Stack

- **Runtime**: Node.js
- **Framework**: Express.js
- **Database**: MongoDB with Mongoose ODM
- **Authentication**: JWT (JSON Web Tokens)
- **Validation**: express-validator
- **URL Scraping**: axios + cheerio

## ğŸ“ Project Structure
```
backend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â””â”€â”€ database.js
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ Note.js
â”‚   â”‚   â”œâ”€â”€ Bookmark.js
â”‚   â”‚   â””â”€â”€ User.js
â”‚   â”œâ”€â”€ controllers/
â”‚   â”‚   â”œâ”€â”€ noteController.js
â”‚   â”‚   â”œâ”€â”€ bookmarkController.js
â”‚   â”‚   â””â”€â”€ authController.js
â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â”œâ”€â”€ noteRoutes.js
â”‚   â”‚   â”œâ”€â”€ bookmarkRoutes.js
â”‚   â”‚   â””â”€â”€ authRoutes.js
â”‚   â”œâ”€â”€ middlewares/
â”‚   â”‚   â”œâ”€â”€ auth.js
â”‚   â”‚   â”œâ”€â”€ validate.js
â”‚   â”‚   â””â”€â”€ errorHandler.js
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”œâ”€â”€ urlMetadata.js
â”‚   â”‚   â””â”€â”€ validators.js
â”‚   â””â”€â”€ app.js
â”œâ”€â”€ .env
â”œâ”€â”€ server.js
â””â”€â”€ package.json
```

## âœ¨ Bonus Features Implemented

âœ… Auto-fetch URL title for bookmarks  
âœ… JWT authentication  
âœ… User-specific data filtering  
âœ… Mark favorites  
âœ… Advanced search with tags  
âœ… Comprehensive validation  

## ğŸ› Error Handling

The API includes comprehensive error handling for:
- Validation errors
- Database errors
- Authentication errors
- Invalid URLs
- Missing resources (404)

## ğŸ“ Notes

- MongoDB must be running before starting the server
- Default port is 5000 (configurable in .env)
- JWT tokens expire in 30 days
- All timestamps are automatically managed

## ğŸ¤ Support

For issues or questions, please check the error messages in the response or server logs.
</file>

<file path="backend/server.js">
const express = require('express');
const dotenv = require('dotenv');
const cors = require('cors');
const connectDB = require('./src/config/database');
const errorHandler = require('./src/middlewares/errorHandler');

// Load environment variables
dotenv.config();

// Initialize express app
const app = require('./src/app');

// Connect to database
connectDB();

const PORT = process.env.PORT || 5000;

app.listen(PORT, () => {
  console.log(`ğŸš€ Server running on port ${PORT}`);
  console.log(`ğŸ“ Environment: ${process.env.NODE_ENV}`);
});
</file>

<file path="backend/src/app.js">
const express = require('express');
const cors = require('cors');
const noteRoutes = require('./routes/noteRoutes');
const bookmarkRoutes = require('./routes/bookmarkRoutes');
const authRoutes = require('./routes/authRoutes');
const errorHandler = require('./middlewares/errorHandler');

const app = express();

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Health check route
app.get('/health', (req, res) => {
  res.status(200).json({ 
    status: 'success', 
    message: 'Server is running!' 
  });
});

// API Routes
app.use('/api/notes', noteRoutes);
app.use('/api/bookmarks', bookmarkRoutes);
app.use('/api/auth', authRoutes);

// 404 handler
app.use((req, res) => {
  res.status(404).json({
    status: 'error',
    message: 'Route not found'
  });
});

// Global error handler
app.use(errorHandler);

module.exports = app;
</file>

<file path="backend/src/config/database.js">
const mongoose = require('mongoose');

const connectDB = async () => {
  try {
    const conn = await mongoose.connect(process.env.MONGODB_URI);
    console.log(`âœ… MongoDB Connected: ${conn.connection.host}`);
  } catch (error) {
    console.error(`âŒ MongoDB Connection Error: ${error.message}`);
    process.exit(1);
  }
};

module.exports = connectDB;
</file>

<file path="backend/src/controllers/authController.js">
const User = require('../models/User');
const jwt = require('jsonwebtoken');

// Generate JWT token
const generateToken = (userId) => {
  return jwt.sign({ id: userId }, process.env.JWT_SECRET, {
    expiresIn: '30d'
  });
};

// @desc    Register new user
// @route   POST /api/auth/register
// @access  Public
exports.register = async (req, res, next) => {
  try {
    const { name, email, password } = req.body;

    // Check if user exists
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({
        status: 'error',
        message: 'User already exists with this email'
      });
    }

    // Create user
    const user = await User.create({
      name,
      email,
      password
    });

    // Generate token
    const token = generateToken(user._id);

    res.status(201).json({
      status: 'success',
      data: {
        user: {
          id: user._id,
          name: user.name,
          email: user.email
        },
        token
      }
    });
  } catch (error) {
    next(error);
  }
};

// @desc    Login user
// @route   POST /api/auth/login
// @access  Public
exports.login = async (req, res, next) => {
  try {
    const { email, password } = req.body;

    // Validate input
    if (!email || !password) {
      return res.status(400).json({
        status: 'error',
        message: 'Please provide email and password'
      });
    }

    // Find user and include password
    const user = await User.findOne({ email }).select('+password');
    
    if (!user || !(await user.comparePassword(password))) {
      return res.status(401).json({
        status: 'error',
        message: 'Invalid email or password'
      });
    }

    // Generate token
    const token = generateToken(user._id);

    res.status(200).json({
      status: 'success',
      data: {
        user: {
          id: user._id,
          name: user.name,
          email: user.email
        },
        token
      }
    });
  } catch (error) {
    next(error);
  }
};

// @desc    Get current user
// @route   GET /api/auth/me
// @access  Private
exports.getMe = async (req, res, next) => {
  try {
    const user = await User.findById(req.user.id);

    res.status(200).json({
      status: 'success',
      data: {
        user: {
          id: user._id,
          name: user.name,
          email: user.email
        }
      }
    });
  } catch (error) {
    next(error);
  }
};
</file>

<file path="backend/src/controllers/bookmarkController.js">
const Bookmark = require('../models/Bookmark');
const { fetchURLMetadata } = require('../utils/urlMetadata');

// @desc    Get all bookmarks with optional search and filters
// @route   GET /api/bookmarks?q=searchTerm&tags=tag1,tag2
// @access  Public (or Private if auth enabled)
exports.getBookmarks = async (req, res, next) => {
  try {
    const { q, tags } = req.query;
    let query = {};

    // Add user filter if authenticated
    if (req.user) {
      query.user = req.user.id;
    }

    // Text search
    if (q) {
      query.$or = [
        { title: { $regex: q, $options: 'i' } },
        { description: { $regex: q, $options: 'i' } },
        { url: { $regex: q, $options: 'i' } }
      ];
    }

    // Tag filter
    if (tags) {
      const tagArray = tags.split(',').map(tag => tag.trim().toLowerCase());
      query.tags = { $in: tagArray };
    }

    const bookmarks = await Bookmark.find(query).sort({ createdAt: -1 });

    res.status(200).json({
      status: 'success',
      results: bookmarks.length,
      data: {
        bookmarks
      }
    });
  } catch (error) {
    next(error);
  }
};

// @desc    Get single bookmark by ID
// @route   GET /api/bookmarks/:id
// @access  Public (or Private if auth enabled)
exports.getBookmark = async (req, res, next) => {
  try {
    let query = { _id: req.params.id };

    // Add user filter if authenticated
    if (req.user) {
      query.user = req.user.id;
    }

    const bookmark = await Bookmark.findOne(query);

    if (!bookmark) {
      return res.status(404).json({
        status: 'error',
        message: 'Bookmark not found'
      });
    }

    res.status(200).json({
      status: 'success',
      data: {
        bookmark
      }
    });
  } catch (error) {
    next(error);
  }
};

// @desc    Create new bookmark
// @route   POST /api/bookmarks
// @access  Public (or Private if auth enabled)
exports.createBookmark = async (req, res, next) => {
  try {
    let { url, title, description, tags, isFavorite } = req.body;

    // Auto-fetch title if not provided (BONUS FEATURE)
    if (!title || title.trim() === '') {
      const metadata = await fetchURLMetadata(url);
      title = metadata.title || url;
    }

    const bookmarkData = {
      url,
      title,
      description: description || '',
      tags: tags || [],
      isFavorite: isFavorite || false
    };

    // Add user if authenticated
    if (req.user) {
      bookmarkData.user = req.user.id;
    }

    const bookmark = await Bookmark.create(bookmarkData);

    res.status(201).json({
      status: 'success',
      data: {
        bookmark
      }
    });
  } catch (error) {
    next(error);
  }
};

// @desc    Update bookmark
// @route   PUT /api/bookmarks/:id
// @access  Public (or Private if auth enabled)
exports.updateBookmark = async (req, res, next) => {
  try {
    let query = { _id: req.params.id };

    // Add user filter if authenticated
    if (req.user) {
      query.user = req.user.id;
    }

    const bookmark = await Bookmark.findOneAndUpdate(
      query,
      req.body,
      {
        new: true,
        runValidators: true
      }
    );

    if (!bookmark) {
      return res.status(404).json({
        status: 'error',
        message: 'Bookmark not found'
      });
    }

    res.status(200).json({
      status: 'success',
      data: {
        bookmark
      }
    });
  } catch (error) {
    next(error);
  }
};

// @desc    Delete bookmark
// @route   DELETE /api/bookmarks/:id
// @access  Public (or Private if auth enabled)
exports.deleteBookmark = async (req, res, next) => {
  try {
    let query = { _id: req.params.id };

    // Add user filter if authenticated
    if (req.user) {
      query.user = req.user.id;
    }

    const bookmark = await Bookmark.findOneAndDelete(query);

    if (!bookmark) {
      return res.status(404).json({
        status: 'error',
        message: 'Bookmark not found'
      });
    }

    res.status(200).json({
      status: 'success',
      message: 'Bookmark deleted successfully',
      data: null
    });
  } catch (error) {
    next(error);
  }
};
</file>

<file path="backend/src/controllers/noteController.js">
const Note = require('../models/Note');

// @desc    Get all notes with optional search and filters
// @route   GET /api/notes?q=searchTerm&tags=tag1,tag2
// @access  Public (or Private if auth enabled)
exports.getNotes = async (req, res, next) => {
    try {
        const { q, tags } = req.query;
        let query = {};

        // Add user filter if authenticated
        if (req.user) {
            query.user = req.user.id;
        }

        // Text search
        if (q) {
            query.$or = [
                { title: { $regex: q, $options: 'i' } },
                { content: { $regex: q, $options: 'i' } }
            ];
        }

        // Tag filter
        if (tags) {
            const tagArray = tags.split(',').map(tag => tag.trim().toLowerCase());
            query.tags = { $in: tagArray };
        }

        const notes = await Note.find(query).sort({ createdAt: -1 });

        res.status(200).json({
            status: 'success',
            results: notes.length,
            data: {
                notes
            }
        });
    } catch (error) {
        next(error);
    }
};

// @desc    Get single note by ID
// @route   GET /api/notes/:id
// @access  Public (or Private if auth enabled)
exports.getNote = async (req, res, next) => {
    try {
        let query = { _id: req.params.id };

        // Add user filter if authenticated
        if (req.user) {
            query.user = req.user.id;
        }

        const note = await Note.findOne(query);

        if (!note) {
            return res.status(404).json({
                status: 'error',
                message: 'Note not found'
            });
        }

        res.status(200).json({
            status: 'success',
            data: {
                note
            }
        });
    } catch (error) {
        next(error);
    }
};

// @desc    Create new note
// @route   POST /api/notes
// @access  Public (or Private if auth enabled)
exports.createNote = async (req, res, next) => {
    try {
        const { title, content, tags, isFavorite } = req.body;

        const noteData = {
            title,
            content,
            tags: tags || [],
            isFavorite: isFavorite || false
        };

        // Add user if authenticated
        if (req.user) {
            noteData.user = req.user.id;
        }

        const note = await Note.create(noteData);

        res.status(201).json({
            status: 'success',
            data: {
                note
            }
        });
    } catch (error) {
        next(error);
    }
};

// @desc    Update note
// @route   PUT /api/notes/:id
// @access  Public (or Private if auth enabled)
exports.updateNote = async (req, res, next) => {
    try {
        let query = { _id: req.params.id };

        // Add user filter if authenticated
        if (req.user) {
            query.user = req.user.id;
        }

        const note = await Note.findOneAndUpdate(
            query,
            req.body,
            {
                new: true,
                runValidators: true
            }
        );

        if (!note) {
            return res.status(404).json({
                status: 'error',
                message: 'Note not found'
            });
        }

        res.status(200).json({
            status: 'success',
            data: {
                note
            }
        });
    } catch (error) {
        next(error);
    }
};

// @desc    Delete note
// @route   DELETE /api/notes/:id
// @access  Public (or Private if auth enabled)
exports.deleteNote = async (req, res, next) => {
    try {
        let query = { _id: req.params.id };

        // Add user filter if authenticated
        if (req.user) {
            query.user = req.user.id;
        }

        const note = await Note.findOneAndDelete(query);

        if (!note) {
            return res.status(404).json({
                status: 'error',
                message: 'Note not found'
            });
        }

        res.status(200).json({
            status: 'success',
            message: 'Note deleted successfully',
            data: null
        });
    } catch (error) {
        next(error);
    }
};
</file>

<file path="backend/src/middlewares/auth.js">
const jwt = require('jsonwebtoken');
const User = require('../models/User');

// Protect routes - require authentication
exports.protect = async (req, res, next) => {
  try {
    let token;

    // Check for token in headers
    if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
      token = req.headers.authorization.split(' ')[1];
    }

    if (!token) {
      return res.status(401).json({
        status: 'error',
        message: 'Not authorized, no token provided'
      });
    }

    // Verify token
    const decoded = jwt.verify(token, process.env.JWT_SECRET);

    // Get user from token
    req.user = await User.findById(decoded.id).select('-password');

    if (!req.user) {
      return res.status(401).json({
        status: 'error',
        message: 'User not found'
      });
    }

    next();
  } catch (error) {
    return res.status(401).json({
      status: 'error',
      message: 'Not authorized, token invalid'
    });
  }
};

// Optional auth - attach user if token exists, but don't require it
exports.optionalAuth = async (req, res, next) => {
  try {
    let token;

    if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
      token = req.headers.authorization.split(' ')[1];
    }

    if (token) {
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      req.user = await User.findById(decoded.id).select('-password');
    }

    next();
  } catch (error) {
    // If token is invalid, just continue without user
    next();
  }
};
</file>

<file path="backend/src/middlewares/errorHandler.js">
const errorHandler = (err, req, res, next) => {
  console.error('Error:', err);

  // Mongoose validation error
  if (err.name === 'ValidationError') {
    const errors = Object.values(err.errors).map(e => e.message);
    return res.status(400).json({
      status: 'error',
      message: 'Validation failed',
      errors
    });
  }

  // Mongoose duplicate key error
  if (err.code === 11000) {
    const field = Object.keys(err.keyPattern)[0];
    return res.status(400).json({
      status: 'error',
      message: `${field} already exists`
    });
  }

  // Mongoose cast error (invalid ID)
  if (err.name === 'CastError') {
    return res.status(400).json({
      status: 'error',
      message: 'Invalid ID format'
    });
  }

  // JWT errors
  if (err.name === 'JsonWebTokenError') {
    return res.status(401).json({
      status: 'error',
      message: 'Invalid token'
    });
  }

  if (err.name === 'TokenExpiredError') {
    return res.status(401).json({
      status: 'error',
      message: 'Token expired'
    });
  }

  // Default error
  res.status(err.statusCode || 500).json({
    status: 'error',
    message: err.message || 'Internal server error'
  });
};

module.exports = errorHandler;
</file>

<file path="backend/src/middlewares/validate.js">
const { body, validationResult } = require('express-validator');

// Validation middleware wrapper
const validate = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({
      status: 'error',
      message: 'Validation failed',
      errors: errors.array()
    });
  }
  next();
};

// Note validation rules
exports.validateNote = [
  body('title')
    .trim()
    .notEmpty()
    .withMessage('Title is required')
    .isLength({ max: 200 })
    .withMessage('Title cannot exceed 200 characters'),
  body('content')
    .trim()
    .notEmpty()
    .withMessage('Content is required'),
  body('tags')
    .optional()
    .isArray()
    .withMessage('Tags must be an array'),
  body('isFavorite')
    .optional()
    .isBoolean()
    .withMessage('isFavorite must be a boolean'),
  validate
];

// Bookmark validation rules
exports.validateBookmark = [
  body('url')
    .trim()
    .notEmpty()
    .withMessage('URL is required')
    .isURL()
    .withMessage('Please provide a valid URL'),
  body('title')
    .optional()
    .trim()
    .isLength({ max: 300 })
    .withMessage('Title cannot exceed 300 characters'),
  body('description')
    .optional()
    .trim()
    .isLength({ max: 1000 })
    .withMessage('Description cannot exceed 1000 characters'),
  body('tags')
    .optional()
    .isArray()
    .withMessage('Tags must be an array'),
  body('isFavorite')
    .optional()
    .isBoolean()
    .withMessage('isFavorite must be a boolean'),
  validate
];

// Register validation rules
exports.validateRegister = [
  body('name')
    .trim()
    .notEmpty()
    .withMessage('Name is required'),
  body('email')
    .trim()
    .notEmpty()
    .withMessage('Email is required')
    .isEmail()
    .withMessage('Please provide a valid email')
    .normalizeEmail(),
  body('password')
    .notEmpty()
    .withMessage('Password is required')
    .isLength({ min: 6 })
    .withMessage('Password must be at least 6 characters'),
  validate
];

// Login validation rules
exports.validateLogin = [
  body('email')
    .trim()
    .notEmpty()
    .withMessage('Email is required')
    .isEmail()
    .withMessage('Please provide a valid email')
    .normalizeEmail(),
  body('password')
    .notEmpty()
    .withMessage('Password is required'),
  validate
];
</file>

<file path="backend/src/models/Bookmark.js">
const mongoose = require('mongoose');

const bookmarkSchema = new mongoose.Schema({
  url: {
    type: String,
    required: [true, 'URL is required'],
    trim: true,
    match: [
      /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)$/,
      'Please provide a valid URL'
    ]
  },
  title: {
    type: String,
    required: [true, 'Title is required'],
    trim: true,
    maxlength: [300, 'Title cannot exceed 300 characters']
  },
  description: {
    type: String,
    trim: true,
    maxlength: [1000, 'Description cannot exceed 1000 characters']
  },
  tags: [{
    type: String,
    trim: true,
    lowercase: true
  }],
  isFavorite: {
    type: Boolean,
    default: false
  },
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: false // Make optional for non-auth version
  }
}, {
  timestamps: true
});

// Index for search optimization
bookmarkSchema.index({ title: 'text', description: 'text' });
bookmarkSchema.index({ tags: 1 });
bookmarkSchema.index({ user: 1 });

module.exports = mongoose.model('Bookmark', bookmarkSchema);
</file>

<file path="backend/src/models/Note.js">
const mongoose = require('mongoose');

const noteSchema = new mongoose.Schema({
  title: {
    type: String,
    required: [true, 'Title is required'],
    trim: true,
    maxlength: [200, 'Title cannot exceed 200 characters']
  },
  content: {
    type: String,
    required: [true, 'Content is required']
  },
  tags: [{
    type: String,
    trim: true,
    lowercase: true
  }],
  isFavorite: {
    type: Boolean,
    default: false
  },
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: false // Make optional for non-auth version
  }
}, {
  timestamps: true
});

// Index for search optimization
noteSchema.index({ title: 'text', content: 'text' });
noteSchema.index({ tags: 1 });
noteSchema.index({ user: 1 });

module.exports = mongoose.model('Note', noteSchema);
</file>

<file path="backend/src/models/User.js">
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const userSchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, 'Name is required'],
    trim: true
  },
  email: {
    type: String,
    required: [true, 'Email is required'],
    unique: true,
    lowercase: true,
    trim: true,
    match: [/^\S+@\S+\.\S+$/, 'Please provide a valid email']
  },
  password: {
    type: String,
    required: [true, 'Password is required'],
    minlength: [6, 'Password must be at least 6 characters'],
    select: false
  }
}, {
  timestamps: true
});

// Hash password before saving
userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();
  
  const salt = await bcrypt.genSalt(10);
  this.password = await bcrypt.hash(this.password, salt);
  next();
});

// Compare password method
userSchema.methods.comparePassword = async function(candidatePassword) {
  return await bcrypt.compare(candidatePassword, this.password);
};

module.exports = mongoose.model('User', userSchema);
</file>

<file path="backend/src/routes/authRoutes.js">
const express = require('express');
const { register, login, getMe } = require('../controllers/authController');
const { protect } = require('../middlewares/auth');
const { validateRegister, validateLogin } = require('../middlewares/validate');

const router = express.Router();

router.post('/register', validateRegister, register);
router.post('/login', validateLogin, login);
router.get('/me', protect, getMe);

module.exports = router;
</file>

<file path="backend/src/routes/bookmarkRoutes.js">
const express = require('express');
const {
  getBookmarks,
  getBookmark,
  createBookmark,
  updateBookmark,
  deleteBookmark
} = require('../controllers/bookmarkController');
const { protect, optionalAuth } = require('../middlewares/auth');
const { validateBookmark } = require('../middlewares/validate');

const router = express.Router();

// Apply optional auth - works with or without token
router.use(optionalAuth);

router.route('/')
  .get(getBookmarks)
  .post(validateBookmark, createBookmark);

router.route('/:id')
  .get(getBookmark)
  .put(validateBookmark, updateBookmark)
  .delete(deleteBookmark);

module.exports = router;
</file>

<file path="backend/src/routes/noteRoutes.js">
const express = require('express');
const {
  getNotes,
  getNote,
  createNote,
  updateNote,
  deleteNote
} = require('../controllers/noteController');
const { protect, optionalAuth } = require('../middlewares/auth');
const { validateNote } = require('../middlewares/validate');

const router = express.Router();

// Apply optional auth - works with or without token
router.use(optionalAuth);

router.route('/')
  .get(getNotes)
  .post(validateNote, createNote);

router.route('/:id')
  .get(getNote)
  .put(validateNote, updateNote)
  .delete(deleteNote);

module.exports = router;
</file>

<file path="backend/src/utils/urlMetadata.js">
const axios = require('axios');
const cheerio = require('cheerio');

// Fetch URL metadata (title) - BONUS FEATURE
exports.fetchURLMetadata = async (url) => {
  try {
    const response = await axios.get(url, {
      timeout: 5000,
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
      }
    });

    const $ = cheerio.load(response.data);

    // Try multiple meta tags for title
    let title = 
      $('meta[property="og:title"]').attr('content') ||
      $('meta[name="twitter:title"]').attr('content') ||
      $('title').text() ||
      url;

    return {
      title: title.trim(),
      success: true
    };
  } catch (error) {
    console.error('Error fetching URL metadata:', error.message);
    return {
      title: url,
      success: false
    };
  }
};
</file>

<file path="backend/src/utils/validators.js">
// URL validation helper
exports.isValidURL = (url) => {
  const urlPattern = /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)$/;
  return urlPattern.test(url);
};

// Tag sanitization
exports.sanitizeTags = (tags) => {
  if (!Array.isArray(tags)) return [];
  return tags.map(tag => tag.trim().toLowerCase()).filter(tag => tag.length > 0);
};
</file>

<file path="frontend/.eslintrc.json">
{
  "extends": "next/core-web-vitals"
}
</file>

<file path="frontend/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
.yarn/install-state.gz

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="frontend/jsconfig.json">
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"],
      "@/components/*": ["./src/components/*"],
      "@/lib/*": ["./src/lib/*"],
      "@/utils/*": ["./src/utils/*"],
      "@/hooks/*": ["./src/hooks/*"]
    }
  },
  "exclude": ["node_modules", ".next"]
}
</file>

<file path="frontend/next.config.mjs">
/** @type {import('next').NextConfig} */
const nextConfig = {
    reactStrictMode: true,
    swcMinify: true,
};

export default nextConfig;
</file>

<file path="frontend/package.json">
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "next": "14.2.35",
    "react": "^18",
    "react-dom": "^18"
  },
  "devDependencies": {
    "autoprefixer": "^10.4.24",
    "eslint": "^8",
    "eslint-config-next": "14.2.35",
    "postcss": "^8.5.6",
    "tailwindcss": "^3.4.1"
  }
}
</file>

<file path="frontend/postcss.config.mjs">
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};

export default config;
</file>

<file path="frontend/README.md">
# ğŸ“ Notes & Bookmarks Manager - Frontend

Modern, responsive React application built with Next.js 14 and Tailwind CSS for managing personal notes and bookmarks.

## ğŸš€ Quick Start

### Prerequisites
- Node.js (v14+)
- Backend API running on `http://localhost:5000`

### Installation

1. **Install dependencies**
```bash
   npm install
```

2. **Configure environment variables**
```bash
   cp .env.local.example .env.local
```
   
   Edit `.env.local`:
```env
   NEXT_PUBLIC_API_URL=http://localhost:5000/api
```

3. **Run the development server**
```bash
   npm run dev
```

4. **Open your browser**
```
   http://localhost:3000
```

## ğŸ“¦ Build for Production
```bash
npm run build
npm start
```

## ğŸ¨ Features

### Notes Management
- âœ… Create, read, update, delete notes
- âœ… Rich text content support
- âœ… Tag organization
- âœ… Search by title/content
- âœ… Filter by tags
- âœ… Mark as favorite
- âœ… Responsive cards layout

### Bookmarks Management
- âœ… Save URLs with metadata
- âœ… Auto-fetch page titles
- âœ… Add descriptions
- âœ… Tag organization
- âœ… Search across title/URL/description
- âœ… Filter by tags
- âœ… Mark as favorite
- âœ… Open in new tab

### UI/UX Features
- âœ… Fully responsive design (mobile, tablet, desktop)
- âœ… Clean, modern interface
- âœ… Modal dialogs for forms
- âœ… Toast notifications
- âœ… Loading states
- âœ… Smooth animations
- âœ… Intuitive navigation
- âœ… Accessibility features

## ğŸ“ Project Structure
```
frontend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”œâ”€â”€ layout.jsx              # Root layout
â”‚   â”‚   â”œâ”€â”€ page.jsx                # Home page
â”‚   â”‚   â”œâ”€â”€ globals.css             # Global styles
â”‚   â”‚   â”œâ”€â”€ notes/
â”‚   â”‚   â”‚   â””â”€â”€ page.jsx            # Notes page
â”‚   â”‚   â””â”€â”€ bookmarks/
â”‚   â”‚       â””â”€â”€ page.jsx            # Bookmarks page
â”‚   â”‚
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ layout/
â”‚   â”‚   â”‚   â””â”€â”€ Header.jsx          # Navigation header
â”‚   â”‚   â”œâ”€â”€ notes/
â”‚   â”‚   â”‚   â”œâ”€â”€ NoteCard.jsx        # Note display card
â”‚   â”‚   â”‚   â”œâ”€â”€ NoteForm.jsx        # Create/Edit form
â”‚   â”‚   â”‚   â””â”€â”€ NoteList.jsx        # Notes grid
â”‚   â”‚   â”œâ”€â”€ bookmarks/
â”‚   â”‚   â”‚   â”œâ”€â”€ BookmarkCard.jsx    # Bookmark display card
â”‚   â”‚   â”‚   â”œâ”€â”€ BookmarkForm.jsx    # Create/Edit form
â”‚   â”‚   â”‚   â””â”€â”€ BookmarkList.jsx    # Bookmarks grid
â”‚   â”‚   â””â”€â”€ common/
â”‚   â”‚       â”œâ”€â”€ SearchBar.jsx       # Search input
â”‚   â”‚       â”œâ”€â”€ TagFilter.jsx       # Tag filtering
â”‚   â”‚       â””â”€â”€ Modal.jsx           # Modal dialog
â”‚   â”‚
â”‚   â”œâ”€â”€ lib/
â”‚   â”‚   â””â”€â”€ api.js                  # API client
â”‚   â”‚
â”‚   â””â”€â”€ utils/
â”‚       â””â”€â”€ constants.js            # Helper functions
â”‚
â”œâ”€â”€ public/
â”œâ”€â”€ .env.local
â”œâ”€â”€ jsconfig.json
â”œâ”€â”€ next.config.js
â”œâ”€â”€ tailwind.config.js
â”œâ”€â”€ postcss.config.js
â””â”€â”€ package.json
```

## ğŸ› ï¸ Tech Stack

- **Framework**: Next.js 14 (App Router)
- **React**: 18.2
- **Styling**: Tailwind CSS 3.3
- **HTTP Client**: Axios
- **Icons**: React Icons
- **Notifications**: React Hot Toast
- **State Management**: React Hooks

## ğŸ“± Responsive Breakpoints

- **Mobile**: < 640px
- **Tablet**: 640px - 1024px
- **Desktop**: > 1024px

## ğŸ¨ Color Scheme

Primary colors defined in Tailwind config:
- Primary: Blue (#3b82f6)
- Success: Green (#10b981)
- Error: Red (#ef4444)
- Warning: Yellow (#f59e0b)

## ğŸ’¡ Key Features

### JSX Format
- All React components use `.jsx` extension
- Better IDE support and syntax highlighting
- Clear separation between React and utility files

### Path Aliases
- `@/components/*` - Component imports
- `@/lib/*` - API and utilities
- `@/utils/*` - Helper functions

### Accessibility
- ARIA labels on interactive elements
- Keyboard navigation support
- Screen reader friendly
- Focus management in modals

## ğŸ› Troubleshooting

**Can't connect to API:**
- Check backend is running on port 5000
- Verify `.env.local` has correct API URL
- Check browser console for CORS errors

**Styles not loading:**
- Run `npm install` again
- Clear `.next` folder: `rm -rf .next`
- Restart dev server

**Changes not reflecting:**
- Hard refresh browser (Ctrl/Cmd + Shift + R)
- Clear browser cache

## ğŸ“ Environment Variables
```env
NEXT_PUBLIC_API_URL=http://localhost:5000/api
```

âš ï¸ **Important**: Variables must start with `NEXT_PUBLIC_` to be accessible in the browser.

## ğŸš€ Deployment

For production deployment:

1. Build the app: `npm run build`
2. Set production API URL in environment
3. Deploy to Vercel, Netlify, or any Node.js hosting
4. Ensure backend API is accessible from deployment

---

**Built with â¤ï¸ using Next.js 14, React 18, and Tailwind CSS**
</file>

<file path="frontend/tailwind.config.js">
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./src/pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/components/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {
      colors: {
        background: "var(--background)",
        foreground: "var(--foreground)",
        primary: {
          50: '#eff6ff',
          100: '#dbeafe',
          200: '#bfdbfe',
          300: '#93c5fd',
          400: '#60a5fa',
          500: '#3b82f6',
          600: '#2563eb',
          700: '#1d4ed8',
          800: '#1e40af',
          900: '#1e3a8a',
        }
      },
      animation: {
        'fade-in': 'fadeIn 0.3s ease-in-out',
      },
      keyframes: {
        fadeIn: {
          '0%': { opacity: '0', transform: 'translateY(10px)' },
          '100%': { opacity: '1', transform: 'translateY(0)' },
        },
      },
    },
  },
  plugins: [],
};
</file>

<file path="package.json">
{
  "dependencies": {
    "axios": "^1.13.5",
    "react-hot-toast": "^2.6.0",
    "react-icons": "^5.5.0"
  }
}
</file>

</files>
